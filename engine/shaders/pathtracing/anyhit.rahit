#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_EXT_buffer_reference : require

layout(set = 0, binding = 0) uniform sampler2D texSamplers[];

#include "../includes/texindices.glsl"
layout(set = 6, binding = 0) readonly buffer TexIndexBuffer {
    TexIndices texIndices[];
};

#include "../includes/meshdata.glsl"
#include "../includes/raypayloads.glsl"

layout(location = 0) rayPayloadInEXT PrimaryPayload payload;
hitAttributeEXT vec2 hit;

vec2 getUV(uint index) {
    uint64_t vertAddr = texIndices[gl_InstanceCustomIndexEXT].vertexAddress;
    uint64_t indexAddr = texIndices[gl_InstanceCustomIndexEXT].indexAddress;

    IndexBuffer indexBuffer = IndexBuffer(indexAddr);
    VertBuffer vertBuffer = VertBuffer(vertAddr);

    uint i0 = indexBuffer.indices[index + 0];
    uint i1 = indexBuffer.indices[index + 1];
    uint i2 = indexBuffer.indices[index + 2];

    vec2 uv0 = vertBuffer.vertices[i0].tex;
    vec2 uv1 = vertBuffer.vertices[i1].tex;
    vec2 uv2 = vertBuffer.vertices[i2].tex;

    return barycentricvec2(uv0, uv1, uv2, hit.x, hit.y);
}

vec4 getAlbedo(TexIndices texIndices, vec2 uv) {
    bool albedoExists = (texIndices.albedo >= 0);

    if (albedoExists) {
        return texture(texSamplers[texIndices.albedo], uv);
    }

    return vec4(1.0f, 0.0f, 0.0f, 1.0f);  // red if no albedo
}

void main() {
    // get uv
    uint index = 3 * gl_PrimitiveID;
    vec2 uv = getUV(index);

    // get albedo
    vec4 albedo = getAlbedo(texIndices[gl_InstanceCustomIndexEXT], uv);

    // if translucent ignore intersection
    if (albedo.a < 0.9f) {
        ignoreIntersectionEXT;
    }
}
